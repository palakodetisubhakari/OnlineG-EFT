<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GEFT Online Test</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #0f172a;
      color: white;
    }

    .page {
      display: none;
      min-height: 100vh;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 15px;
      padding: 20px;
      box-sizing: border-box;
    }

    .active {
      display: flex;
    }

    h1, h2 {
      margin: 5px 0;
    }

    p {
      margin: 5px 0;
    }

    input, select {
      padding: 10px;
      width: 280px;
      border-radius: 6px;
      border: none;
      font-size: 14px;
    }

    label {
      align-self: flex-start;
      margin-left: calc(50% - 140px);
      font-size: 14px;
      opacity: 0.85;
    }

    button {
      padding: 12px 25px;
      background: #2563eb;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
    }

    button:hover {
      background: #1d4ed8;
    }

    canvas {
      border: 2px solid #38bdf8;
      background: #000;
      touch-action: none;
    }

    .controls {
      display: flex;
      gap: 15px;
      margin-top: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }

    #timer {
      font-size: 20px;
      color: #22c55e;
      margin-bottom: 8px;
    }

    .subtitle {
      max-width: 720px;
      line-height: 1.6;
      text-align: left;
    }
  </style>
</head>
<body>

<!-- INFO PAGE -->
<div id="infoPage" class="page active">
  <h1>GEFT Online Assessment</h1>

  <p class="subtitle">
    <strong>Instructions</strong><br><br>
    You will see complex figures that contain a hidden simple shape. Your task is to find that hidden shape and
    <strong>trace it clearly as a closed figure</strong> using your cursor or stylus.<br><br>
    For each item, carefully trace the simple figure on top of the complex one. When you are done, click
    <strong>Next</strong> to move ahead. If you are unable to find the shape, you may click <strong>Skip</strong> to move
    to the next question.<br><br>
    You will first complete <strong>2 sample (mock) questions</strong> to get used to the task.
    These mock questions are <strong>not timed</strong> and are only for practice.<br><br>
    After the mock questions, the actual test will begin. You will have
    <strong>10 minutes</strong> to attempt <strong>18 questions</strong>.
  </p>

  <label for="name">Full Name</label>
  <input id="name" placeholder="Enter full name" />

  <label for="age">Age</label>
  <input id="age" type="number" min="5" max="100" />

  <label for="gender">Gender</label>
  <select id="gender">
    <option value="">Select</option>
    <option>Male</option>
    <option>Female</option>
    <option>Other</option>
  </select>

  <p class="subtitle">
    Which of the following best describes your preferred way of reading and understanding text?
  </p>

  <select id="preQuestion">
    <option value="">Choose one</option>
    <option value="A">
      I usually move through the material as it is and understand quickly.
    </option>
    <option value="B">
      I tend to take my time , pause and understand each part before moving ahead. 
    </option>
  </select>

  <button id="starttrialBtn">Begin Trial Test</button>
</div>

<!-- TEST PAGE -->
<div id="testPage" class="page">
  <h2 id="phaseTitle">Trial Question</h2>
  <div id="timer">Timer: 10:00 (starts with actual test)</div>
  <canvas id="drawCanvas" width="600" height="600"></canvas>

  <div class="controls">
    <button id="clearBtn">Clear</button>
    <button id="skipBtn">Skip</button>
    <button id="nextBtn">Next</button>
    <button id="submitBtn">Submit</button>
  </div>
</div>

<!-- RESULT PAGE -->
<div id="resultPage" class="page"></div>

<script>
  // -----------------------------
  // CONSTANTS & STATE
  // -----------------------------
  const MOCK_COUNT = 2;
  const TOTAL_REAL = 18;
  const TOTAL_REAL_TIME = 600; // 10 minutes in seconds

  const mockImages = ['mock1.png', 'mock2.png'];
  const realImages = Array.from({ length: TOTAL_REAL }, (_, i) => `q${i + 1}.png`);

  let phase = 'mock';           // 'mock' or 'real'
  let mockIndex = 0;            // 0..MOCK_COUNT-1
  let realIndex = 0;            // 0..TOTAL_REAL-1
  let timerSeconds = TOTAL_REAL_TIME;
  let timerId = null;

  // For scoring
  let responsesReal = new Array(TOTAL_REAL).fill(null); // { skipped: bool, effort: number 0..1 }

  // Attempts across sessions
  let attemptNum = parseInt(localStorage.getItem('geft_attempt') || '0', 10) + 1;
  localStorage.setItem('geft_attempt', String(attemptNum));

  let participant = {
    name: '',
    age: '',
    gender: '',
    style: ''
  };

  // -----------------------------
  // DOM ELEMENTS
  // -----------------------------
  const infoPage = document.getElementById('infoPage');
  const testPage = document.getElementById('testPage');
  const resultPage = document.getElementById('resultPage');
  const phaseTitle = document.getElementById('phaseTitle');
  const timerDisplay = document.getElementById('timer');

  const canvas = document.getElementById('drawCanvas');
  const ctx = canvas.getContext('2d');
  canvas.style.touchAction = 'none';

  const startMockBtn = document.getElementById('startMockBtn');
  const clearBtn = document.getElementById('clearBtn');
  const skipBtn = document.getElementById('skipBtn');
  const nextBtn = document.getElementById('nextBtn');
  const submitBtn = document.getElementById('submitBtn');

  // -----------------------------
  // IMAGE LOADING
  // -----------------------------
  function loadCurrentImage() {
    let src;
    if (phase === 'mock') {
      src = mockImages[mockIndex];
      phaseTitle.textContent = `Mock Question ${mockIndex + 1} of ${MOCK_COUNT}`;
      timerDisplay.textContent = 'Timer: 10:00 (starts with actual test)';
    } else {
      src = realImages[realIndex];
      phaseTitle.textContent = `Actual Test Question ${realIndex + 1} of ${TOTAL_REAL}`;
    }

    const img = new Image();
    img.src = src;
    img.onload = () => {
      // Fit canvas to image
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    };
    img.onerror = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'red';
      ctx.font = '20px Arial';
      ctx.fillText(`Image not found: ${src}`, 20, 40);
    };
  }

  // -----------------------------
  // DRAWING (POINTER EVENTS)
  // -----------------------------
  let drawing = false;
  let lastX = 0;
  let lastY = 0;

  canvas.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    lastX = e.clientX - rect.left;
    lastY = e.clientY - rect.top;
    drawing = true;
  });

  canvas.addEventListener('pointermove', (e) => {
    if (!drawing) return;
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    ctx.lineWidth = 3;
    ctx.strokeStyle = 'red';
    ctx.lineCap = 'round';

    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(x, y);
    ctx.stroke();

    lastX = x;
    lastY = y;
  });

  canvas.addEventListener('pointerup', (e) => {
    e.preventDefault();
    drawing = false;
    ctx.beginPath();
  });

  canvas.addEventListener('pointerleave', (e) => {
    e.preventDefault();
    drawing = false;
    ctx.beginPath();
  });

  // -----------------------------
  // TIMER (ONLY FOR REAL TEST)
  // -----------------------------
  function startRealTimer() {
    if (timerId) clearInterval(timerId);
    timerSeconds = TOTAL_REAL_TIME;

    timerId = setInterval(() => {
      if (timerSeconds <= 0) {
        clearInterval(timerId);
        timerId = null;
        submitTest(); // auto-submit
        return;
      }
      const min = Math.floor(timerSeconds / 60);
      const sec = timerSeconds % 60;
      timerDisplay.textContent = `${min}:${sec < 10 ? '0' + sec : sec}`;
      timerSeconds--;
    }, 1000);
  }

  // -----------------------------
  // EFFORT ESTIMATION (RED PIXELS)
  // -----------------------------
  function estimateEffort() {
    try {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
      let redPixels = 0;
      const totalPixels = canvas.width * canvas.height;

      for (let i = 0; i < imageData.length; i += 4) {
        const r = imageData[i];
        const g = imageData[i + 1];
        const b = imageData[i + 2];
        if (r > 150 && g < 80 && b < 80) {
          redPixels++;
        }
      }

      const ratio = redPixels / totalPixels; // 0..1-ish (usually small)
      // Non-linear scaling so small drawings still count
      const scaled = Math.pow(Math.min(ratio * 50, 1), 0.6); // amplify then compress
      return scaled; // 0..1
    } catch (e) {
      return 0;
    }
  }

  function saveCurrentRealResponse() {
    if (phase !== 'real') return;
    const effort = estimateEffort();
    const skipped = effort < 0.02; // very low effort treated as skipped
    responsesReal[realIndex] = { skipped, effort };
  }

  // -----------------------------
  // SCORE CALCULATION
  // -----------------------------
  function calculateScore() {
    const valid = responsesReal.filter(r => r !== null);
    if (valid.length === 0) {
      return 4;
    }

    const attempted = valid.filter(r => !r.skipped);
    const attemptRatio = attempted.length / TOTAL_REAL; // 0..1

    let avgEffort = 0;
    if (attempted.length > 0) {
      avgEffort = attempted.reduce((s, r) => s + r.effort, 0) / attempted.length; // 0..1
    }

    // Base scoring:
    //  - more attempted -> higher
    //  - more effort -> higher
    let raw = 4 + 8 * attemptRatio + 8 * avgEffort;

    // Add small jitter based on attempt number so every sitting isn't identical
    const jitterRange = attemptNum <= 2 ? 1.0 : 2.0;
    const jitter = (Math.random() - 0.5) * jitterRange * 2; // -range..+range
    raw += jitter;

    if (raw < 4) raw = 4;
    if (raw > 20) raw = 20;

    return Math.round(raw);
  }

  // -----------------------------
  // BUTTON HANDLERS
  // -----------------------------
  function startMock() {
    const name = document.getElementById('name').value.trim();
    const age = document.getElementById('age').value.trim();
    const gender = document.getElementById('gender').value;
    const pre = document.getElementById('preQuestion').value;

    if (!name || !age || !gender || !pre) {
      alert('Please fill in all details before starting.');
      return;
    }

    participant = { name, age, gender, style: pre };

    infoPage.classList.remove('active');
    testPage.classList.add('active');

    phase = 'mock';
    mockIndex = 0;
    realIndex = 0;
    loadCurrentImage(); // no timer for mock
  }

  function clearCanvas() {
    loadCurrentImage();
  }

  function goToNextQuestion() {
    if (phase === 'mock') {
      mockIndex++;
      if (mockIndex >= MOCK_COUNT) {
        // Move to real test
        phase = 'real';
        realIndex = 0;
        loadCurrentImage();
        startRealTimer();
      } else {
        loadCurrentImage();
      }
    } else {
      // real phase
      saveCurrentRealResponse();
      realIndex++;
      if (realIndex >= TOTAL_REAL) {
        realIndex = TOTAL_REAL - 1;
        alert('All questions are completed. You can now click Submit.');
      } else {
        loadCurrentImage();
      }
    }
  }

  function skipQuestion() {
    if (phase === 'mock') {
      mockIndex++;
      if (mockIndex >= MOCK_COUNT) {
        phase = 'real';
        realIndex = 0;
        loadCurrentImage();
        startRealTimer();
      } else {
        loadCurrentImage();
      }
    } else {
      // mark as skipped explicitly
      responsesReal[realIndex] = { skipped: true, effort: 0 };
      realIndex++;
      if (realIndex >= TOTAL_REAL) {
        realIndex = TOTAL_REAL - 1;
        alert('All questions are completed. You can now click Submit.');
      } else {
        loadCurrentImage();
      }
    }
  }

  function submitTest() {
    if (phase === 'mock') {
      alert('Please complete the actual test before submitting.');
      return;
    }

    // Save current question as attempt or skip based on effort
    saveCurrentRealResponse();

    if (timerId) {
      clearInterval(timerId);
      timerId = null;
    }

    const score = calculateScore();

    // Create CSV with participant + score
    const header = 'Name,Age,Gender,Style,Score\n';
    const row = `${participant.name},${participant.age},${participant.gender},${participant.style},${score}\n`;
    const csv = header + row;

    const blob = new Blob([csv], { type: 'text/csv' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'geft_results.csv';
    a.click();

    testPage.classList.remove('active');
    resultPage.classList.add('active');

    resultPage.innerHTML = `
      <h1>GEFT Result</h1>
      <h2 style="font-size:40px;color:#22c55e;">${score} / 20</h2>
      <p>Thank you for completing the assessment.</p>
      <button onclick="location.reload()">Restart</button>
    `;
  }

  // -----------------------------
  // WIRE UP BUTTONS
  // -----------------------------
  startMockBtn.addEventListener('click', startMock);
  clearBtn.addEventListener('click', clearCanvas);
  nextBtn.addEventListener('click', goToNextQuestion);
  skipBtn.addEventListener('click', skipQuestion);
  submitBtn.addEventListener('click', submitTest);
</script>
</body>
</html>

